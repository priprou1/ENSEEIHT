/**
 * @file minishell.c
 * @author Priscilia Gonthier
 * @brief Interpréteur de commandes simplifié, offrant les fonctionnalités de base des shells UNIX.
 * @date 2022-05-25
 */

#include "readcmd.h"
#include "listeProcessus.h"
#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>


#define IDSIZE 20
#define CAPACITE 100

int nbProc = 1; //nb de processus
processusArriere listeProc[CAPACITE];
pid_t pidFg = -1;
char affichage[CAPACITE] = "";

/*********************************************Handler*********************************************/

/* handler de SIGCHDL */
void handlerSigchld(int sig, siginfo_t *siginfo, void *contexte) {
    int pidFils, codeFin;
    do {
        pidFils = (int) waitpid(-1, &codeFin, WNOHANG | WUNTRACED | WCONTINUED);
        if ((pidFils == -1) && (errno != ECHILD)) {
            perror("waitpid");
            exit(2);
        } else if (pidFils > 0) {
            int position = positionProcessus(listeProc, pidFils);
            if (position != -1) {
                if (WIFEXITED(codeFin)) {
                    if (pidFils != pidFg) {
                        int idProc = idProcessus(listeProc, pidFils);
                        char idProcChaine[10];
                        sprintf(idProcChaine, "%d", idProc); // converti un int en string
                        strcat(affichage, "[");
                        strcat(affichage, idProcChaine);
                        strcat(affichage, "] Processus arrêté : ");
                        strcat(affichage, commandeProcessus(listeProc, pidFils));
                        strcat(affichage, "\n");
                    } else {
                        pidFg = -1;
                    }
                    supprimerProcessus(listeProc, pidFils);
                }
            }
        }
    } while (pidFils > 0);
}

/* handler de SIGINT */
void handlerSigint(int sig, siginfo_t *siginfo, void *contexte) {
    if (pidFg != -1) {
        kill(pidFg, SIGKILL);
        supprimerProcessus(listeProc, pidFg);
        printf("\n");
        pidFg = -1;
    }
}

/* handler de SIGTSTP */
void handlerSigtstp(int sig, siginfo_t *siginfo, void *contexte) {
    if (pidFg != -1) {
        kill(pidFg, SIGSTOP);
        suspendreProcessus(listeProc, pidFg);
        printf("\n[%d]+ Suspension  %d  %s\n", idProcessus(listeProc, pidFg), pidFg, commandeProcessus(listeProc, pidFg));
        pidFg = -1;
        nbProc++;
    }
}

/***************************************Commandes Internes****************************************/

void changeDirectory(int i, struct cmdline *commande) {
    if (commande->seq[i][1] == NULL || (strcmp(commande->seq[i][1], "$HOME") == 0)) {
        chdir(getenv("HOME"));
    } else {
        int ret = chdir(commande->seq[i][1]);
        if (ret == -1) {
            printf("%s: Répertoire non trouvé\n", commande->seq[i][1]);
        }
    }
}

void stopJob(int i, processusArriere *listeProc, struct cmdline *commande) {
    if (commande->seq[i][1] != NULL) {
        int id = atoi(commande->seq[i][1]);
        pid_t pid;
        pid = pidProcessus(listeProc, id);
        if (pid != -1) {
            kill(pid, SIGSTOP);
            suspendreProcessus(listeProc, pid);
            char idProcChaine[10];
            sprintf(idProcChaine, "%d", id);
            strcat(affichage, "[");
            strcat(affichage, idProcChaine);
            strcat(affichage, "] Processus en arrière plan suspendu : ");
            strcat(affichage, commandeProcessus(listeProc, pid));
            strcat(affichage, "\n");
        } else {
            printf("Erreur : Processus inexistant.\n");
        }
    } else {
        printf("USAGE : sj [identifiant du processus géré par le minishell >= 1] .\n");
    }
}

void backgroundJob(int i, processusArriere *listeProc, struct cmdline *commande) {
    if (commande->seq[i][1] != NULL) {
        int id = atoi(commande->seq[i][1]);
        pid_t pid;
        pid = pidProcessus(listeProc, id);
        if (pid != -1) {
            kill(pid, SIGCONT);
            reprendreProcessus(listeProc, pid);
            char idProcChaine[10];
            sprintf(idProcChaine, "%d", id);
            strcat(affichage, "[");
            strcat(affichage, idProcChaine);
            strcat(affichage, "] Processus repris en arrière plan : ");
            strcat(affichage, commandeProcessus(listeProc, pid));
            strcat(affichage, "\n");
        } else {
            printf("Erreur : Processus inexistant.\n");
        }
    } else {
        printf("USAGE : bg [identifiant du processus géré par le minishell >= 1] .\n");
    }
}
void foregroundJob(int i, processusArriere *listeProc, struct cmdline *commande) {
    if (commande->seq[i][1] != NULL) {
        int id = atoi(commande->seq[i][1]);
        pid_t pid;
        pid = pidProcessus(listeProc, id);
        if (pid != -1) {
            int codeTerm;
            printf("%s\n", commandeProcessus(listeProc, pid));
            kill(pid, SIGCONT);
            pidFg = pid;
            while (pidFg != -1) {
                pause(); // Permet d'attendre la fin d'exécution des fils sans utiliser waitpid(), car il est dans le handler
            }
            //wait(&codeTerm);
            supprimerProcessus(listeProc, pid);
        } else {
            printf("Erreur : Processus inexistant.\n");
        }
    } else {
        printf("USAGE : fg [identifiant du processus géré par le minishell >= 1] .\n");
    }
}

/******************************************Redirections*******************************************/

void redirigerSortie(char* fichier) {
    int sortie = open (fichier, O_WRONLY| O_CREAT | O_TRUNC, 0640);
    if (sortie < 0) {
        perror(fichier);
        exit(1);
    }
    int duplication = dup2(sortie, 1);
    if (duplication == -1) {
        printf("Erreur dup2\n");
        exit(1);
    }
}

void redirigerEntree(char* fichier) {
    int entree = open (fichier, O_RDONLY);
    if (entree < 0) {
        perror(fichier);
        exit(1);
    }
    int duplication = dup2(entree, 0);
    if (duplication == -1) {
        printf("Erreur dup2 \n");
        exit(1);
    }
}


/**************************************************************************************************
----------------------------------------Programme Principal----------------------------------------
**************************************************************************************************/

int main(int argc, char *argv[]) {

    bool boucle = true;
    //listeProc = malloc(CAPACITE);
    pid_t pidFils;
    sigset_t setMasque;
    char repertoire[250];
    
    // Gestion du signal SIGCHLD
    struct sigaction actionSigchld;

    actionSigchld.sa_sigaction = handlerSigchld;
    actionSigchld.sa_flags = SA_SIGINFO | SA_RESTART;
    sigemptyset(&actionSigchld.sa_mask);

    sigaction(SIGCHLD, &actionSigchld, NULL);


    // Gestion du signal SIGINT, pour le ctrl-C
    struct sigaction actionSigint;

    actionSigint.sa_sigaction = handlerSigint;
    actionSigint.sa_flags = SA_SIGINFO | SA_RESTART;
    sigemptyset(&actionSigint.sa_mask);

    sigaction(SIGINT, &actionSigint, NULL);


    // Gestion du signal SIGTSTP, pour le ctrl-Z
    struct sigaction actionSigtstp;

    actionSigtstp.sa_sigaction = handlerSigtstp;
    actionSigtstp.sa_flags = SA_SIGINFO | SA_RESTART;
    sigemptyset(&actionSigtstp.sa_mask);

    sigaction(SIGTSTP, &actionSigtstp, NULL);


    // Masque des signaux pour les processus fils
    sigemptyset(&setMasque);
    sigaddset(&setMasque, SIGINT);
    sigaddset(&setMasque, SIGTSTP);


    while (boucle) {
        printf("Minishell:%s>>> ", getcwd(repertoire,250));
        fflush(stdout);
        struct cmdline *commande;
        commande = readcmd();
        if (commande == NULL || commande->err != NULL || commande->seq == NULL || commande->seq[0] == NULL) {
            // Permet d'éviter des erreurs de segmentation si aucune commande n'a été rentrée lors du readcmd()
            NULL;
        } else if(strcmp(commande->seq[0][0], "exit") == 0) {
            // Quitter le minishell 
            boucle = false;
        } else if (strcmp(commande->seq[0][0], "cd") == 0) {
            // Changer de répertoire
            changeDirectory(0, commande);
        } else if (strcmp(commande->seq[0][0], "lj") == 0) {
            // Afficher la liste des processus
            listeProcessus(listeProc);
        } else if (strcmp(commande->seq[0][0], "sj") == 0) {
            // Suspendre un processus en arrrière-plan
            stopJob(0, listeProc, commande);
        } else if (strcmp(commande->seq[0][0], "bg") == 0) {
            // Reprendre un processus en arrière-plan
            backgroundJob(0, listeProc, commande);
        } else if (strcmp(commande->seq[0][0], "fg") == 0) {
            // Reprendre un processus au premier-plan
            foregroundJob(0, listeProc, commande);
        } else if (strcmp(commande->seq[0][0], "susp") == 0) {
            // Suspendre le minishell
            int ret = kill(getpid(), SIGSTOP);
            if (ret < 0) {
                perror("Erreur de suspension du minishell");
                exit(1);
            } else {
                printf("Reprise du minishell\n");
            }
        } else if (commande->seq[1] == NULL) {
            pidFils = fork();
            if (pidFils < 0) {
                printf("ECHEC : Erreur fork\n");
                exit(1);
            } else if (pidFils == 0) { /* fils */
                sigprocmask(SIG_BLOCK, &setMasque, NULL);
                if (commande->in != NULL) {
                    redirigerEntree(commande->in);
                }
                if (commande->out != NULL) {
                    redirigerSortie(commande->out);
                }
                int execute = execvp(commande->seq[0][0], commande->seq[0]);
                if (execute < 0) {
                    exit(2);
                }
                exit(EXIT_SUCCESS);
            } else { /* père */
                char commandeProc[200] = "";
                int j = 0;
                while(commande->seq[0][j] != NULL) {
                    strcat(commandeProc,commande->seq[0][j]);
                    strcat(commandeProc," ");
                    j++;
                }
                ajouterProcessus(listeProc, nbProc, pidFils, commandeProc);
                
                if (commande->backgrounded == NULL) {
                    pidFg = pidFils;
                    while (pidFg != -1) {
                        pause(); // Permet d'attendre la fin d'exécution des fils sans utiliser waitpid(), car il est dans le handler
                    }
                } else {
                    printf("[%d]  %d\n", nbProc, pidFils);
                    nbProc++;
                }
            }
        } else {
            int wstatus;
            // Création des tubes
            int nbTubes = 0;
            while (commande->seq[nbTubes + 1] != NULL) {
                nbTubes++;
            }
            int p[2 * nbTubes];
            for (int i = 0; i < nbTubes; i++) {
                int ret = pipe(p + i * 2);
                if (ret < 0) {
                    perror("pipe");
                    exit(2);
                }
            }
            // Exécution des fils
            int indiceCommande = 0;
            int indiceP = 0;
            while (commande->seq[indiceCommande] != NULL) {
                pidFils = fork();
                if (pidFils < 0) {
                    printf("ECHEC : Erreur fork\n");
                    exit(1);
                } else if (pidFils == 0) {
                    if (indiceCommande == 0 && commande->in != NULL) {
                        /* Si c'est la première commande on redirige sur l'entrée standard*/
                        redirigerEntree(commande->in);
                    } else if (indiceCommande != 0) {
                        /* Sinon on redirige l'entrée standard vers la sortie de tube précédent */
                        int ret = dup2(p[indiceP - 2], 0);
                        if (ret < 0) {
                            printf("Erreur dup2\n");
                            exit(2);
                        }
                    }
                    if (indiceCommande == nbTubes && commande->out != NULL) {
                        /* Si c'est la dernière commande on redirige sur la sortie standard */
                        redirigerSortie(commande->out);
                    } else  if (indiceCommande != nbTubes) {
                        /* Sinon on redirige la sortie standard vers l'entrée du prochain tube */
                        int ret = dup2(p[indiceP + 1], 1);
                        if (ret < 0) {
                            printf("Erreur dup2\n");
                            exit(2);
                        }
                    }
                    for (int i =0; i < 2*nbTubes; i++) {
                        close(p[i]);
                    }
                    int execute = execvp(commande->seq[indiceCommande][0], commande->seq[indiceCommande]);
                    if (execute < 0) {
                        exit(2);
                    }
                }
                indiceCommande++;
                indiceP += 2;
            }

            // père
            for (int i = 0; i < 2 * nbTubes; i++) {
                close(p[i]);
            }
            for (int i = 0; i <= 2 * nbTubes; i++) {
                wait(&wstatus);
            }
        }
        printf("%s", affichage); // Pour afficher les modifications qui ont été faites pendant l'execution
        affichage[0] = '\0';
    }
    liberer(listeProc);
    return EXIT_SUCCESS;
}
