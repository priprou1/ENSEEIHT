/**
 * @file listeProcessus.c
 * @author Priscilia Gonthier
 * @brief Implantation du module permettant de gérer la liste des processus en arrière plan du minishell.
 * @date 2022-05-25
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <signal.h>
#include "listeProcessus.h"

#define CAPACITE 500


int taille(processusArriere *listeProcessus) {
    int i = 0;
    while (!(listeProcessus[i] == NULL)){ 
            i++;
    }
    return i;
}

int positionProcessus(processusArriere *listeProcessus, pid_t pidProcessus) {
    int tailleListe = taille(listeProcessus);
    int i;
    for (i = 0; i < tailleListe; i++) {
        if (listeProcessus[i]->pid == pidProcessus) {
            return i;
        }
    }
    return -1;
}

bool processusEstInclu(processusArriere *listeProcessus, pid_t pidProcessus) {
        int tailleListe = taille(listeProcessus);
        bool present = false;
        int i;
        for (i = 0; i < tailleListe; i++) {
            if (listeProcessus[i]->pid == pidProcessus) {
                present = true;
            }
        }
        return present;
}

void ajouterProcessus(processusArriere *listeProcessus, int id , pid_t pid, char commande[200]) {
    int tailleListe = taille(listeProcessus)+1;
    if (!processusEstInclu(listeProcessus,pid)) {
        listeProcessus[tailleListe - 1] = malloc(CAPACITE);
        listeProcessus[tailleListe - 1]->idMinishell = id;
        listeProcessus[tailleListe - 1]->pid = pid;
        listeProcessus[tailleListe - 1]->etat = 1;
        strcpy(listeProcessus[tailleListe - 1]->commande, commande);
    }
}

void supprimerProcessus(processusArriere *listeProcessus, pid_t pidProcessus) {
    int tailleListe = taille(listeProcessus);
    int position = positionProcessus(listeProcessus, pidProcessus);
    if(position >= 0){
        for (int i = position; i < tailleListe; i++) {       
            listeProcessus[i] = listeProcessus[i + 1];
        } 
            free(listeProcessus[tailleListe - 1]);
            listeProcessus[tailleListe - 1] = NULL;
    }
}

void suspendreProcessus(processusArriere *listeProcessus, pid_t pidProcessus) {
    int position = positionProcessus(listeProcessus, pidProcessus);
    if(position != -1){
        listeProcessus[position]->etat = 0;   
    }
}

void reprendreProcessus(processusArriere *listeProcessus, pid_t pidProcessus) {
    int position = positionProcessus(listeProcessus, pidProcessus);
    if(processusEstInclu(listeProcessus, pidProcessus)){
        listeProcessus[position]->etat = 1;    
    }
}

pid_t pidProcessus(processusArriere *listeProcessus, int idProcessus) {
    int tailleListe = taille(listeProcessus);
    int i;
    for (i = 0; i < tailleListe; i++) {
        if (listeProcessus[i]->idMinishell == idProcessus) {
            return listeProcessus[i]->pid;
        }
    }
    return -1;
}

int idProcessus(processusArriere *listeProcessus, pid_t pidProcessus) {
    int tailleListe = taille(listeProcessus);
    int i;
    for (i = 0; i < tailleListe; i++) {
        if (listeProcessus[i]->pid == pidProcessus) {
            return listeProcessus[i]->idMinishell;
        }
    }
    return -1;
}

void listeProcessus(processusArriere *listeProcessus) {
    int tailleListe = taille(listeProcessus);
    int i;
    printf(" ID         PID        ETAT    COMMANDE\n");
    for (i=0 ; i < tailleListe ; i++) {
    printf("%3d    %8d    %8s    %s\n",listeProcessus[i]->idMinishell,listeProcessus[i]->pid,
            etatString[listeProcessus[i]->etat],listeProcessus[i]->commande);
    }
}

char *commandeProcessus(processusArriere *listeProcessus, pid_t pidProcessus) {
    int position = positionProcessus(listeProcessus, pidProcessus);
    return listeProcessus[position]->commande;
}

void liberer(processusArriere *listeProcessus) {
    for (int i = 0; i < taille(listeProcessus); i++) {
    kill(listeProcessus[i]->pid, SIGKILL);
    }
}
